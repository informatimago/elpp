;;; Commentary:

;; Useful functions for autogenerating C and C++ code.
;; This package is not meant to be complete. Rather, it is meant to establish
;; a consistent method for generating C code.

;; Usage:

;; This package is basically designed to build a string which represents
;; your program. Building strings turns out to be more appropriate than
;; accumulating data into a buffer, as will become evident shortly. This
;; string can then be `insert'ed into a buffer using `c-out'.

;; Typical use involves calling `c-pretty' to pretty-print chunks of your
;; code, `c-print' to accumulate several statements together, and `c-out'
;; to insert into a buffer. Other functions in this package allow you to
;; build statements (`c-statement'), conditionals, assignments, comparisons,
;; etc.
;;
;; To generate the code
;;
;; if ( test_situation(vv) ) {
;;   b = a;
;; }
;;
;; You would call:
;;
;; (c-if (c-funcall "test_situation" '(vv))
;;       (c-block (c-statement (c-assignment "b" "a"))))
;;
;; The reason for accumulating things into strings rather than buffers
;; should be apparent now: `c-funcall' is evaluated before `c-if', and
;; if it `c-funcall' had the side affect of inserting into a buffer, the
;; output of c-if would happen after the call to test_situation(). Which
;; is bogus. There are hacks around this, but who wants to do that??

;; Bugs:

;; Strings are not a good way to accumulate things. Rather, a union data
;; structure should be used. I'll do this soon. I'ts just a matter of
;; replacing `c-print' and `c-out' with the right things.


;;; Code:

(require 'cl)


(defun c-print (&rest code)
  "Concatenate a series of C expressions together."
  (apply 'concat (mapcar (lambda (x) (prin1-to-string x t)) code)))

(defun c-out (&rest code)
  "Insert expressions into the current buffer."
  (insert (apply 'c-print code)))

(defun c-pretty (&rest code)
  "Format the expressions. Does not output to a buffer."
  (let ((old-buffer (current-buffer)))
    (prog1
	(let ((cbuf (generate-new-buffer "*c-indentifyer*")))
	  (set-buffer cbuf)
	  (c-out code)
	  (c-mode)
	  (c-indent-region (point-min) (point-max))
	  (prog1 (buffer-string) (kill-buffer cbuf)))
      (set-buffer old-buffer))))

(defun c-var-decl (type name)
  (c-print type " " name ";"))

(defun c-header (return name args)
  "Output a function header. The only difference with `c-proto' is the
formatting.
This function is mostly used to generate function declarations. It does
not output a semicolon."
  (c-print return " " name "( " (c-args args) " )"))

(defun c-proto (return name args)
  "Output function prototype.
See documentation for `c-entitle-args' for more info on ARGS.
This function is mostly used to generate function declarations."
  (c-print return "\n" name "( "  (c-args args) " )"))

(defun c-function (return name args body)
  "Generate function definiton.
See documentation for `c-entitle-args' for more info on ARGS. BODY is a
block."
  (c-print (c-proto return name args) (c-block body) "\n\n"))

(defun c-function2 (proto body)
  "Second form of `c-function'.
PROTO is the result of a `c-proto'."
  (c-print proto (c-block body) "\n\n"))

(defun c-if (condition yes &optional no)
  "Generate a conditional.
Optional argument NO results in an else clause being generated."
  (c-print "if( " condition " )" yes "\n"
	   (if no (c-print "else" no) "")))

(defun c-block (code)
  (c-print "\n{\n" code "}\n"))

(defun c-statement (&rest code)
  "Turns the elements of CODE into semicolon separate statements."
  (apply #'c-print
	 (mapcar (lambda (stm) (c-print stm ";\n")) code)))

(defun c-assignment (lhs rhs)
  (c-print lhs " = " rhs))

(defun c-eq (lhs rhs)
  (c-print lhs " == " rhs))

(defun c-identifier (&rest strings)
  "Build up an identifier name from its parts.
Variable names such as foo_1, foo_2, foo_3 can be generated by
 calling (c-identifier "foo" 1) (c-identifier "foo" 2) (c-identifer "foo" 3)."
  (apply 'c-print strings))

(defun c-funcall (func args)
  "Generate a function call.
ARGS is a list of argument names."
  (c-print func "( " (if (car args) (car args) "")
	   (apply 'c-print (mapcar (lambda (v) (c-print ", " v)) (cdr args)))
	   " )"))

(defun c-comment (&rest comments)
  (c-print "// " (apply #'c-print comments) "\n"))

(defun var-type (var) (car var))
(defun var-name (var) (cadr var))
(defun var-named-p (var) (caddr var))

(defun c-entitle-args (args &optional arg-num)
  "Accepts a list of the form

((TYPE1 [NAME1]) (TYPE2 [NAME2]) (TYPE3 [NAME3]) ...)

TYPEi must always be specified, but NAMEi is optional. If NAMEi
is omitted, the string \"argi\" will be used instead. If there is
only one type in the argument list, you may use \"TYPE\" instead of
((TYPE)), or (TYPE NAME) instead of ((TYPE NAME))."
  (cond
   ((null args) args)
   ((and (consp args) (consp (car args)))
    (cons
     (if (var-name (car args))
	 (append (car args) '(t))
       (list (var-type (car args))
	     (c-identifier "arg" (number-to-string (if arg-num arg-num 1)))
	     'nil))
     (c-entitle-args (cdr args) (1+ (if arg-num arg-num 1)))))

    ((consp args) (c-entitle-args (list args)))
    (t (c-entitle-args (list (list args))))))

(defun c-args (args)
  "Generate an argument list for function decl or defn.
See `c-entitle-args' for info on how to specify argument lists."
  (c-print
   (var-type (car args)) " " (var-name (car args))
   (apply 'c-print
	  (mapcar (lambda (arg)
		    (c-print ", " (var-type arg) " " (var-name arg)))
		  (cdr args)))))

(defun c-commaify-list (lst)
  "Outputs the elements of the, separating each element with a comma."
  (c-print (car lst)
	   (apply 'c-print
		  (mapcar (lambda (arg) (c-print ", " arg))  (cdr lst)))))

(defun c-pointerify-variable (var)
  "Turns a var decl into a pointer decl.
VAR is an element of an args list suitable for `c-entitle-args'."
  (list  (c-identifier (var-type var) "* ") (var-name var) (var-named-p var)))

(defun c-pointerify-variables (vars)
  "Pointerify all the variables in VARS.
VARS has the same format as args in `c-entitle-args'."
  (mapcar 'c-pointerify-variable vars))

(defun c-list-to-array (lst)
  (if (atom lst) (c-print lst)
    (c-print "\n{ "
	     (c-commaify-list (mapcar 'list-to-array lst))
	     " }")))
